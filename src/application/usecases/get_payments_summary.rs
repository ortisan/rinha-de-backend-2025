use crate::application::domain::payment::{GetPaymentsFilter, Payment, PaymentsSummary};use crate::constants::PAYMENTS_KEY;use crate::infrastructure;use log::info;use redis::Commands;use std::sync::Arc;#[derive(Clone)]pub struct GetPaymentsSummaryUsecase {    redis_client: Arc<redis::Client>,}impl GetPaymentsSummaryUsecase {    pub fn new(redis_client: Arc<redis::Client>) -> Self {        GetPaymentsSummaryUsecase { redis_client }    }    pub async fn execute(        &self,        get_payments_filter: GetPaymentsFilter,    ) -> infrastructure::Result<PaymentsSummary> {        let min_key = get_payments_filter.from.timestamp_nanos_opt().unwrap();        let max_key = get_payments_filter.to.timestamp_nanos_opt().unwrap();        info!(            "Getting payments summary. To: {}, From: {}",            min_key, max_key        );        let mut conn = self.redis_client.get_connection()?;        let payments: Vec<String> = conn.zrangebyscore(PAYMENTS_KEY, min_key, max_key)?;        let mut total_payments: u64 = 0;        let mut total_amount: f64 = 0.0;        payments.iter().for_each(|x| {            let payment: Payment = serde_json::from_str(x).unwrap();            total_payments += 1;            total_amount += payment.amount;        });        Ok(PaymentsSummary {            total_payments,            total_amount,        })    }}